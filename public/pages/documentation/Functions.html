<div id="documentation-container">
    <h1>Functions as First Class Citizens</h1>
    <p>
        Functions being First Class Citizens means that they can be passed around as arguments, can return other functions, and be stored in variables. You could for example have an array of functions if you wanted to. This feature also makes callback functions possible.
        Some examples of functions being FCC below
    </p>

    <pre>
        <code>
            const functionArray = [
                (a, b) => a + b,
                message => `Here is your message: ${message}`,
                (a, b, c) => {
                    console.log(a, b, c);
                    return a + b * c;
                }
            ];

            const functionReturningAnotherFunction = () => {
                return (name) => `Hello, ${name}`
            }

        </code>
    </pre>

    <h1>3 different ways to create a function</h1>
    <p
        >Besides the syntax, there are some differences between an arrow (also called anonymous) function and a regular function. Because of the differences, an arrow function should not be used as a method. Here is 2 of the differences:
    </p>
    <ul>
        <li>An arrow function can't be used as a constructor and will throw a TypeError exception.</li>
        <li>An arrow function using the "this keyword" will not refer to the same "this" as a regular function.</li>
    </ul>
    <p>The first example is a function declaration</p>

    <pre>
        <code>
            function regularFunction(message) {
                console.log(message);
            };
        </code>
    </pre>

    <p>
        The second example is a function expression
    </p>

    <pre>
        <code>
            const functionExpression = function(message) {
                console.log(message)
            };
        </code>
    </pre>

    <p>
        The third and last example is an arrow function expression
    </p>

    <pre>
        <code>
            const arrowFunctionExpression = message => {
                console.log(message);
            };
        </code>
    </pre>
    <p>
        Note that you don't have to have parentheses around the parameter if there is only a single parameter. If you have 0 or more than 1 parameter, you will have to include the parentheses
    </p>
    <p>
        if your arrow function's body only contains a single expression, you can omit the curly braces and the return keyword, since the return is implicit. If you want to return an object this way, you will have to wrap the expression in parentheses, like in the example below
    </p>

    <pre>
        <code>
            const implicitlyReturningAnObject = () => ({ message: 'hello' })
        </code>
    </pre>

    <h1>Async functions</h1>
    <p>
        Using the "async" keyword will make the function return a promise. The async keyword allows you to use await in the function body, which is used to stop further execution of the function until the promise resolves. You used to only be able to use await inside async functions, but from NodeJS version 14.8.0 and onwards, you can also use await in the global scope of a module, but only if you are using ECMAScript modules.
    </p>

    <h1>Callback functions</h1>
    <p>A callback function is a function that is given as a parameter to another function. An example showing how to use callback functions will be given in the loop methods section below</p>

    <h1>Array's iterative methods</h1>
    <p>The Array data type has a bunch of iterative methods. All of these methods take a callback function and then loops through the array, calling the callback function with the current element as a parameter. A couple of examples are shown below</p>

    <pre>
        <code>
            const bird = birds.find(bird => bird.id === Number(req.params.id))
        </code>
    </pre>
    <p>
        The array.find() method will loop through the array, calling the callback function with each bird element until the expression in the method body returns true. When true is returned, the find() functions returns the current bird element.
    </p>
    <pre>
        <code>
            const bird = birds.filter(bird => bird.age === Number(req.params.age))
        </code>
    </pre>
    <p>
        This array.filter() method is similar to the find method, but instead of stopping the first time true is returned, it loops through the entire array, storing each element that returns true in another array. When there are no more elements to loop through, the filter() method returns the array containing all the elements that returned true.
    </p>

    <pre>
        <code>
            const users = [
                { name: 'user1', age: 30 },
                { name: 'user2', age: 49 }, 
                { name: 'user3', age: 18 },
                { name: 'user4', age: 55 },
                { name: 'user5', age: 32 }
                ]

                const ages = users.map(user => user.age)
        </code>
    </pre>
    <p>
        the array.map() method iterates through the array and returns a new array with the values returned   from each call of the callback function. The ages variable in the above example contains an array with all the users' ages.
    </p>



</div>